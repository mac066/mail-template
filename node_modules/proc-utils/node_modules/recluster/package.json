{
  "name": "recluster",
  "version": "0.4.5",
  "description": "Clustering library with support for zero-downtime reloading",
  "main": "index.js",
  "scripts": {
    "test": "tap test/index.js test/termination.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/doxout/recluster.git"
  },
  "keywords": [
    "load",
    "balancer",
    "cluster",
    "zero",
    "downtime",
    "reload",
    "sticky",
    "websockets",
    "socket.io"
  ],
  "author": {
    "name": "spion"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "00dcf38ed8e8198da83e350372f92237f81677d7",
  "directories": {
    "test": "test"
  },
  "devDependencies": {
    "tap": "~0.4.1"
  },
  "readme": "# recluster\n\nClustering library with support for zero-downtime reloading\n\n# usage\n\nIf server.js is your regular http server (e.g. express), create\ncluster.js and add:\n\n```js\nvar recluster = require('recluster'),\n    path = require('path');\n\nvar cluster = recluster(path.join(__dirname, 'server.js'));\ncluster.run();\n\nprocess.on('SIGUSR2', function() {\n    console.log('Got SIGUSR2, reloading cluster...');\n    cluster.reload();\n});\n\nconsole.log(\"spawned cluster, kill -s SIGUSR2\", process.pid, \"to reload\");\n```\n\nthen run it\n\n    node cluster.js\n\nTo hot-reload the server, simply run\n\n    kill -s SIGUSR2 <cluster_pid>\n\nTo find out which of the N (= number of cores by default) worker\ninstances you're running from inside server.js, you can use\n\n    process.env.WORKER_ID\n\nwhich is zero-based i.e. 0 <= WORKER_ID < N\n\n# options\n\n```js\nvar cluster = recluster(file, opt)\n```\n\nwhere\n\n### file\n\nAbsolute path to the module that defines the server\n\n### opt.workers\n\nNumber of active workers (default = cores)\n\n### opt.timeout\n\nTimeout to kill old workers after reload (seconds).\n\nDefaults to 1 second in development, 1 hour in production.\n\n### opt.respawn\n\nMinimum time between worker respawns when workers die (seconds)\n\n### opt.backoff\n\nMaximum respawn time (reached via exponential backoff). Set to\n0 or undefined to disable exponential backoff.\n\n### opt.readyWhen\n\nUse `'listening'` for servers (e.g. for express/connect http servers)\nand `'started'` for workers that are immediately ready.\n\nIf you want to manually tell recluster when the worker is ready to replace\nolder workers you can use `{readyWhen: 'ready'}`. Then, to signal readiness\nfrom the worker use `process.send({cmd: 'ready'})`\n\n### opt.args\n\nArray of arguments to pass to the worker\n\n### opt.log\n\nLog various events to stdout. Currently only 'respawns' is supported.\nDefault: `{respawns: true}`\n\n### opt.logger\n\nWhich logger to use. Requires a console-compatible log method\nDefault: `console`\n\n# cluster\n\nThe returned object has the following methods:\n\n### cluster.run\n\nStarts the cluster by running child processes\n\n### cluster.reload(cb)\n\nHot-reloads new code. some of the children will remain active\nfor `opt.timeout` seconds after reload\n\n### cluster.terminate(cb)\n\nTerminates the entire cluster and removes all listeners.\n\n### cluster.activeWorkers()\n\nReturns a hash of all worker slots (0 <= WORKER_ID < N). If a worker isn't\navailable at that slot, the value in the hash is null or undefined. Otherwise,\nthe value will be a worker object that is ready to serve requests.\n\n### cluster.workers()\n\nReturns an array of all the workers, including those that are not\nyet ready or those that will be replaced.\n\n# worker cleanup\n\nA server worker can gracefully exit by cleaning up in the 'close' event\nof its server:\n\n```js\nserver.on('close', function() {\n    // cleanup\n});\n```\n\nNon-server workers can listen for the disconnect command and shut down\ngracefully before the kill timeout:\n\n```js\nprocess.on('message', function(m) {\n    if (m.cmd == 'disconnect') {\n        // cleanup\n    }\n})\n```\n\n# sticky sessions support\n\nIf you need sticky sessions e.g. for socket.io you can use the experimental\ncompanion module [sticky-listen][sticky-listen], which implements an alternate\nbalancer that distributes the sockets based on the client IP (instead of the\nregular round-robin one)\n\n\n[sticky-listen]: https://github.com/spion/sticky-listen\n\n![Bitdeli](https://d2weczhvl823v0.cloudfront.net/spion/recluster/trend.png)\n\n",
  "bugs": {
    "url": "https://github.com/doxout/recluster/issues"
  },
  "homepage": "https://github.com/doxout/recluster#readme",
  "_id": "recluster@0.4.5",
  "_shasum": "55963e1b29ca5b770355581fde91812872e358a7",
  "_from": "git://github.com/doxout/recluster.git",
  "_resolved": "git://github.com/doxout/recluster.git#7d8539d9fc76aec9f734a374a5c75e53655bb6d3"
}
